/*global jQuery: true */

/*!
   --------------------------------
   Infinite Scroll
   --------------------------------
   + https://github.com/paulirish/infinite-scroll
   + version 2.1.0
   + Copyright 2011/12 Paul Irish & Luke Shumard
   + Licensed under the MIT license

   + Documentation: http://infinite-scroll.com/
*/

// Uses AMD or browser globals to create a jQuery plugin.
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($, undefined) {
    'use strict';

    $.infinitescroll = function infscr(options, callback, element) {
        this.element = $(element);

        // Flag the object in the event of a failed creation
        if (!this._create(options, callback)) {
            this.failed = true;
        }
    };

    $.infinitescroll.defaults = {
        loading: {
            finished: undefined,
            finishedMsg: null,
            img: 'data:image/gif;base64,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',
            msg: null,
            msgText: '<em>Loading more...</em>',
            selector: null,
            speed: 'fast',
            start: undefined
        },
        state: {
            isDuringAjax: false,
            isInvalidPage: false,
            isDestroyed: false,
            isDone: false, // For when it goes all the way through the archive.
            isPaused: false,
            isBeyondMaxPage: false,
            currPage: 1
        },
        debug: false,
        behavior: undefined,
        binder: $(window), // used to cache the selector
        nextSelector: 'div.navigation a:first',
        navSelector: 'div.navigation',
        contentSelector: null, // rename to pageFragment
        extraScrollPx: 150,
        itemSelector: 'div.post',
        animate: false,
        pathParse: undefined,
        dataType: 'html',
        appendCallback: true,
        bufferPx: 40,
        errorCallback: function () { },
        infid: 0, //Instance ID
        pixelsFromNavToBottom: undefined,
        path: undefined, // Either parts of a URL as an array (e.g. ["/page/", "/"] or a function that takes in the page number and returns a URL
        prefill: false, // When the document is smaller than the window, load data until the document is larger or links are exhausted
        maxPage: undefined // to manually control maximum page (when maxPage is undefined, maximum page limitation is not work)
    };

    $.infinitescroll.prototype = {

        /*
            ----------------------------
            Private methods
            ----------------------------
            */

        // Bind or unbind from scroll
        _binding: function infscr_binding(binding) {

            var instance = this,
            opts = instance.options;

            opts.v = '2.0b2.120520';

            // if behavior is defined and this function is extended, call that instead of default
            if (!!opts.behavior && this['_binding_'+opts.behavior] !== undefined) {
                this['_binding_'+opts.behavior].call(this);
                return;
            }

            if (binding !== 'bind' && binding !== 'unbind') {
                this._debug('Binding value  ' + binding + ' not valid');
                return false;
            }

            if (binding === 'unbind') {
                (this.options.binder).unbind('smartscroll.infscr.' + instance.options.infid);
            } else {
                (this.options.binder)[binding]('smartscroll.infscr.' + instance.options.infid, function () {
                    instance.scroll();
                });
            }

            this._debug('Binding', binding);
        },

        // Fundamental aspects of the plugin are initialized
        _create: function infscr_create(options, callback) {

            // Add custom options to defaults
            var opts = $.extend(true, {}, $.infinitescroll.defaults, options);
            this.options = opts;
            var $window = $(window);
            var instance = this;

            // Validate selectors
            if (!instance._validate(options)) {
                return false;
            }

            // Validate page fragment path
            var path = $(opts.nextSelector).attr('href');
            if (!path) {
                this._debug('Navigation selector not found');
                return false;
            }

            // Set the path to be a relative URL from root.
            opts.path = opts.path || this._determinepath(path);

            // contentSelector is 'page fragment' option for .load() / .ajax() calls
            opts.contentSelector = opts.contentSelector || this.element;

            // loading.selector - if we want to place the load message in a specific selector, defaulted to the contentSelector
            opts.loading.selector = opts.loading.selector || opts.contentSelector;

            // Define loading.msg
            opts.loading.msg = opts.loading.msg || $('<div id="infscr-loading"><img alt="Loading..." src="' + opts.loading.img + '" /><div>' + opts.loading.msgText + '</div></div>');

            // Preload loading.img
            (new Image()).src = opts.loading.img;

            // distance from nav links to bottom
            // computed as: height of the document + top offset of container - top offset of nav link
            if(opts.pixelsFromNavToBottom === undefined) {
                opts.pixelsFromNavToBottom = $(document).height() - $(opts.navSelector).offset().top;
                this._debug('pixelsFromNavToBottom: ' + opts.pixelsFromNavToBottom);
            }

            var self = this;

            // determine loading.start actions
            opts.loading.start = opts.loading.start || function() {
                $(opts.navSelector).hide();
                opts.loading.msg
                .appendTo(opts.loading.selector)
                .show(opts.loading.speed, $.proxy(function() {
                    this.beginAjax(opts);
                }, self));
            };

            // determine loading.finished actions
            opts.loading.finished = opts.loading.finished || function() {
                if (!opts.state.isBeyondMaxPage)
                    opts.loading.msg.fadeOut(opts.loading.speed);
            };

            // callback loading
            opts.callback = function(instance, data, url) {
                if (!!opts.behavior && instance['_callback_'+opts.behavior] !== undefined) {
                    instance['_callback_'+opts.behavior].call($(opts.contentSelector)[0], data, url);
                }

                if (callback) {
                    callback.call($(opts.contentSelector)[0], data, opts, url);
                }

                if (opts.prefill) {
                    $window.bind('resize.infinite-scroll', instance._prefill);
                }
            };

            if (options.debug) {
                // Tell IE9 to use its built-in console
                if (Function.prototype.bind && (typeof console === 'object' || typeof console === 'function') && typeof console.log === 'object') {
                    ['log','info','warn','error','assert','dir','clear','profile','profileEnd']
                        .forEach(function (method) {
                            console[method] = this.call(console[method], console);
                        }, Function.prototype.bind);
                }
            }

            this._setup();

            // Setups the prefill method for use
            if (opts.prefill) {
                this._prefill();
            }

            // Return true to indicate successful creation
            return true;
        },

        _prefill: function infscr_prefill() {
            var instance = this;
            var $window = $(window);

            function needsPrefill() {
                return ( $(instance.options.contentSelector).height() <= $window.height() );
            }

            this._prefill = function() {
                if (needsPrefill()) {
                    instance.scroll();
                }

                $window.bind('resize.infinite-scroll', function() {
                    if (needsPrefill()) {
                        $window.unbind('resize.infinite-scroll');
                        instance.scroll();
                    }
                });
            };

            // Call self after setting up the new function
            this._prefill();
        },

        // Console log wrapper
        _debug: function infscr_debug() {
            if (true !== this.options.debug) {
                return;
            }

            if (typeof console !== 'undefined' && typeof console.log === 'function') {
                // Modern browsers
                // Single argument, which is a string
                if ((Array.prototype.slice.call(arguments)).length === 1 && typeof Array.prototype.slice.call(arguments)[0] === 'string') {
                    console.log( (Array.prototype.slice.call(arguments)).toString() );
                } else {
                    console.log( Array.prototype.slice.call(arguments) );
                }
            } else if (!Function.prototype.bind && typeof console !== 'undefined' && typeof console.log === 'object') {
                // IE8
                Function.prototype.call.call(console.log, console, Array.prototype.slice.call(arguments));
            }
        },

        // find the number to increment in the path.
        _determinepath: function infscr_determinepath(path) {

            var opts = this.options;

            // if behavior is defined and this function is extended, call that instead of default
            if (!!opts.behavior && this['_determinepath_'+opts.behavior] !== undefined) {
                return this['_determinepath_'+opts.behavior].call(this,path);
            }

            if (!!opts.pathParse) {

                this._debug('pathParse manual');
                return opts.pathParse(path, this.options.state.currPage+1);

            } else if (path.match(/^(.*?)\b2\b(.*?$)/)) {
                path = path.match(/^(.*?)\b2\b(.*?$)/).slice(1);

                // if there is any 2 in the url at all.
            } else if (path.match(/^(.*?)2(.*?$)/)) {

                // page= is used in django:
                // http://www.infinite-scroll.com/changelog/comment-page-1/#comment-127
                if (path.match(/^(.*?page=)2(\/.*|$)/)) {
                    path = path.match(/^(.*?page=)2(\/.*|$)/).slice(1);
                    return path;
                }

                path = path.match(/^(.*?)2(.*?$)/).slice(1);

            } else {

                // page= is used in drupal too but second page is page=1 not page=2:
                // thx Jerod Fritz, vladikoff
                if (path.match(/^(.*?page=)1(\/.*|$)/)) {
                    path = path.match(/^(.*?page=)1(\/.*|$)/).slice(1);
                    return path;
                } else {
                    this._debug("Sorry, we couldn't parse your Next (Previous Posts) URL. Verify your the css selector points to the correct A tag. If you still get this error: yell, scream, and kindly ask for help at infinite-scroll.com.");
                    // Get rid of isInvalidPage to allow permalink to state
                    opts.state.isInvalidPage = true;  //prevent it from running on this page.
                }
            }
            this._debug('determinePath', path);
            return path;

        },

        // Custom error
        _error: function infscr_error(xhr) {

            var opts = this.options;

            // if behavior is defined and this function is extended, call that instead of default
            if (!!opts.behavior && this['_error_'+opts.behavior] !== undefined) {
                this['_error_'+opts.behavior].call(this,xhr);
                return;
            }

            if (xhr !== 'destroy' && xhr !== 'end') {
                xhr = 'unknown';
            }

            this._debug('Error', xhr);

            if (xhr === 'end' || opts.state.isBeyondMaxPage) {
                this._showdonemsg();
            }

            opts.state.isDone = true;
            opts.state.currPage = 1; // if you need to go back to this instance
            opts.state.isPaused = false;
            opts.state.isBeyondMaxPage = false;
            this._binding('unbind');

        },

        // Load Callback
        _loadcallback: function infscr_loadcallback(box, data, url) {
            var opts = this.options,
            callback = this.options.callback, // GLOBAL OBJECT FOR CALLBACK
            result = (opts.state.isDone) ? 'done' : (!opts.appendCallback) ? 'no-append' : 'append',
            frag;

            // if behavior is defined and this function is extended, call that instead of default
            if (!!opts.behavior && this['_loadcallback_'+opts.behavior] !== undefined) {
                this['_loadcallback_'+opts.behavior].call(this,box,data,url);
                return;
            }

            switch (result) {
                case 'done':
                    this._showdonemsg();
                    return false;

                case 'no-append':
                    if (opts.dataType === 'html') {
                        data = '<div>' + data + '</div>';
                        data = $(data).find(opts.itemSelector);
                    }

                    // if it didn't return anything
                    if (data.length === 0) {
                        return this._error('end');
                    }

                    break;

                case 'append':
                    var children = box.children();
                    // if it didn't return anything
                    if (children.length === 0) {
                        return this._error('end');
                    }

                    // use a documentFragment because it works when content is going into a table or UL
                    frag = document.createDocumentFragment();
                    while (box[0].firstChild) {
                        frag.appendChild(box[0].firstChild);
                    }

                    this._debug('contentSelector', $(opts.contentSelector)[0]);
                    $(opts.contentSelector)[0].appendChild(frag);
                    // previously, we would pass in the new DOM element as context for the callback
                    // however we're now using a documentfragment, which doesn't have parents or children,
                    // so the context is the contentContainer guy, and we pass in an array
                    // of the elements collected as the first argument.

                    data = children.get();
                    break;
            }

            // loadingEnd function
            opts.loading.finished.call($(opts.contentSelector)[0],opts);

            // smooth scroll to ease in the new content
            if (opts.animate) {
                var scrollTo = $(window).scrollTop() + $(opts.loading.msg).height() + opts.extraScrollPx + 'px';
                $('html,body').animate({ scrollTop: scrollTo }, 800, function () { opts.state.isDuringAjax = false; });
            }

            if (!opts.animate) {
                // once the call is done, we can allow it again.
                opts.state.isDuringAjax = false;
            }

            callback(this, data, url);

            if (opts.prefill) {
                this._prefill();
            }
        },

        _nearbottom: function infscr_nearbottom() {

            var opts = this.options,
            pixelsFromWindowBottomToBottom = 0 + $(document).height() - (opts.binder.scrollTop()) - $(window).height();

            // if behavior is defined and this function is extended, call that instead of default
            if (!!opts.behavior && this['_nearbottom_'+opts.behavior] !== undefined) {
                return this['_nearbottom_'+opts.behavior].call(this);
            }

            this._debug('math:', pixelsFromWindowBottomToBottom, opts.pixelsFromNavToBottom);

            // if distance remaining in the scroll (including buffer) is less than the orignal nav to bottom....
            return (pixelsFromWindowBottomToBottom - opts.bufferPx < opts.pixelsFromNavToBottom);

        },

        // Pause / temporarily disable plugin from firing
        _pausing: function infscr_pausing(pause) {

            var opts = this.options;

            // if behavior is defined and this function is extended, call that instead of default
            if (!!opts.behavior && this['_pausing_'+opts.behavior] !== undefined) {
                this['_pausing_'+opts.behavior].call(this,pause);
                return;
            }

            // If pause is not 'pause' or 'resume', toggle it's value
            if (pause !== 'pause' && pause !== 'resume' && pause !== null) {
                this._debug('Invalid argument. Toggling pause value instead');
            }

            pause = (pause && (pause === 'pause' || pause === 'resume')) ? pause : 'toggle';

            switch (pause) {
                case 'pause':
                    opts.state.isPaused = true;
                break;

                case 'resume':
                    opts.state.isPaused = false;
                break;

                case 'toggle':
                    opts.state.isPaused = !opts.state.isPaused;
                break;
            }

            this._debug('Paused', opts.state.isPaused);
            return false;

        },

        // Behavior is determined
        // If the behavior option is undefined, it will set to default and bind to scroll
        _setup: function infscr_setup() {

            var opts = this.options;

            // if behavior is defined and this function is extended, call that instead of default
            if (!!opts.behavior && this['_setup_'+opts.behavior] !== undefined) {
                this['_setup_'+opts.behavior].call(this);
                return;
            }

            this._binding('bind');

            return false;

        },

        // Show done message
        _showdonemsg: function infscr_showdonemsg() {

            var opts = this.options;

            // if behavior is defined and this function is extended, call that instead of default
            if (!!opts.behavior && this['_showdonemsg_'+opts.behavior] !== undefined) {
                this['_showdonemsg_'+opts.behavior].call(this);
                return;
            }

            opts.loading.msg
            .find('img')
            .hide()
            .parent()
            .find('div').html(opts.loading.finishedMsg).animate({ opacity: 1 }, 2000, function () {
                $(this).parent().fadeOut(opts.loading.speed);
            });

            // user provided callback when done
            opts.errorCallback.call($(opts.contentSelector)[0],'done');
        },

        // grab each selector option and see if any fail
        _validate: function infscr_validate(opts) {
            for (var key in opts) {
                if (key.indexOf && key.indexOf('Selector') > -1 && $(opts[key]).length === 0) {
                    this._debug('Your ' + key + ' found no elements.');
                    return false;
                }
            }

            return true;
        },

        /*
            ----------------------------
            Public methods
            ----------------------------
            */

        // Bind to scroll
        bind: function infscr_bind() {
            this._binding('bind');
        },

        // Destroy current instance of plugin
        destroy: function infscr_destroy() {
            this.options.state.isDestroyed = true;
            this.options.loading.finished();
            return this._error('destroy');
        },

        // Set pause value to false
        pause: function infscr_pause() {
            this._pausing('pause');
        },

        // Set pause value to false
        resume: function infscr_resume() {
            this._pausing('resume');
        },

        beginAjax: function infscr_ajax(opts) {
            var instance = this,
                path = opts.path,
                box, desturl, method, condition;

            // increment the URL bit. e.g. /page/3/
            opts.state.currPage++;

            // Manually control maximum page
            if ( opts.maxPage !== undefined && opts.state.currPage > opts.maxPage ){
                opts.state.isBeyondMaxPage = true;
                this.destroy();
                return;
            }

            // if we're dealing with a table we can't use DIVs
            box = $(opts.contentSelector).is('table, tbody') ? $('<tbody/>') : $('<div/>');

            desturl = (typeof path === 'function') ? path(opts.state.currPage) : path.join(opts.state.currPage);
            instance._debug('heading into ajax', desturl);

            method = (opts.dataType === 'html' || opts.dataType === 'json' ) ? opts.dataType : 'html+callback';
            if (opts.appendCallback && opts.dataType === 'html') {
                method += '+callback';
            }

            switch (method) {
                case 'html+callback':
                    instance._debug('Using HTML via .load() method');
                    box.load(desturl + ' ' + opts.itemSelector, undefined, function infscr_ajax_callback(responseText) {
                        instance._loadcallback(box, responseText, desturl);
                    });

                    break;

                case 'html':
                    instance._debug('Using ' + (method.toUpperCase()) + ' via $.ajax() method');
                    $.ajax({
                        // params
                        url: desturl,
                        dataType: opts.dataType,
                        complete: function infscr_ajax_callback(jqXHR, textStatus) {
                            condition = (typeof (jqXHR.isResolved) !== 'undefined') ? (jqXHR.isResolved()) : (textStatus === 'success' || textStatus === 'notmodified');
                            if (condition) {
                                instance._loadcallback(box, jqXHR.responseText, desturl);
                            } else {
                                instance._error('end');
                            }
                        }
                    });

                    break;
                case 'json':
                    instance._debug('Using ' + (method.toUpperCase()) + ' via $.ajax() method');
                    $.ajax({
                        dataType: 'json',
                        type: 'GET',
                        url: desturl,
                        success: function (data, textStatus, jqXHR) {
                            condition = (typeof (jqXHR.isResolved) !== 'undefined') ? (jqXHR.isResolved()) : (textStatus === 'success' || textStatus === 'notmodified');
                            if (opts.appendCallback) {
                                // if appendCallback is true, you must defined template in options.
                                // note that data passed into _loadcallback is already an html (after processed in opts.template(data)).
                                if (opts.template !== undefined) {
                                    var theData = opts.template(data);
                                    box.append(theData);
                                    if (condition) {
                                        instance._loadcallback(box, theData);
                                    } else {
                                        instance._error('end');
                                    }
                                } else {
                                    instance._debug('template must be defined.');
                                    instance._error('end');
                                }
                            } else {
                                // if appendCallback is false, we will pass in the JSON object. you should handle it yourself in your callback.
                                if (condition) {
                                    instance._loadcallback(box, data, desturl);
                                } else {
                                    instance._error('end');
                                }
                            }
                        },
                        error: function() {
                            instance._debug('JSON ajax request failed.');
                            instance._error('end');
                        }
                    });

                    break;
            }
        },

        // Retrieve next set of content items
        retrieve: function infscr_retrieve(pageNum) {
            pageNum = pageNum || null;

            var instance = this,
            opts = instance.options;

            // if behavior is defined and this function is extended, call that instead of default
            if (!!opts.behavior && this['retrieve_'+opts.behavior] !== undefined) {
                this['retrieve_'+opts.behavior].call(this,pageNum);
                return;
            }

            // for manual triggers, if destroyed, get out of here
            if (opts.state.isDestroyed) {
                this._debug('Instance is destroyed');
                return false;
            }

            // we dont want to fire the ajax multiple times
            opts.state.isDuringAjax = true;

            opts.loading.start.call($(opts.contentSelector)[0],opts);
        },

        // Check to see next page is needed
        scroll: function infscr_scroll() {

            var opts = this.options,
            state = opts.state;

            // if behavior is defined and this function is extended, call that instead of default
            if (!!opts.behavior && this['scroll_'+opts.behavior] !== undefined) {
                this['scroll_'+opts.behavior].call(this);
                return;
            }

            if (state.isDuringAjax || state.isInvalidPage || state.isDone || state.isDestroyed || state.isPaused) {
                return;
            }

            if (!this._nearbottom()) {
                return;
            }

            this.retrieve();

        },

        // Toggle pause value
        toggle: function infscr_toggle() {
            this._pausing();
        },

        // Unbind from scroll
        unbind: function infscr_unbind() {
            this._binding('unbind');
        },

        // update options
        update: function infscr_options(key) {
            if ($.isPlainObject(key)) {
                this.options = $.extend(true,this.options,key);
            }
        }
    };


    /*
        ----------------------------
        Infinite Scroll function
        ----------------------------

        Borrowed logic from the following...

        jQuery UI
        - https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.widget.js

        jCarousel
        - https://github.com/jsor/jcarousel/blob/master/lib/jquery.jcarousel.js

        Masonry
        - https://github.com/desandro/masonry/blob/master/jquery.masonry.js

*/

    $.fn.infinitescroll = function infscr_init(options, callback) {


        var thisCall = typeof options;

        switch (thisCall) {

            // method
            case 'string':
                var args = Array.prototype.slice.call(arguments, 1);

                this.each(function () {
                    var instance = $.data(this, 'infinitescroll');

                    if (!instance) {
                        // not setup yet
                        // return $.error('Method ' + options + ' cannot be called until Infinite Scroll is setup');
                        return false;
                    }

                    if (!$.isFunction(instance[options]) || options.charAt(0) === '_') {
                        // return $.error('No such method ' + options + ' for Infinite Scroll');
                        return false;
                    }

                    // no errors!
                    instance[options].apply(instance, args);
                });

            break;

            // creation
            case 'object':

                this.each(function () {

                var instance = $.data(this, 'infinitescroll');

                if (instance) {

                    // update options of current instance
                    instance.update(options);

                } else {

                    // initialize new instance
                    instance = new $.infinitescroll(options, callback, this);

                    // don't attach if instantiation failed
                    if (!instance.failed) {
                        $.data(this, 'infinitescroll', instance);
                    }

                }

            });

            break;

        }

        return this;
    };



    /*
     * smartscroll: debounced scroll event for jQuery *
     * https://github.com/lukeshumard/smartscroll
     * Based on smartresize by @louis_remi: https://github.com/lrbabe/jquery.smartresize.js *
     * Copyright 2011 Louis-Remi & Luke Shumard * Licensed under the MIT license. *
     */

    var event = $.event,
    scrollTimeout;

    event.special.smartscroll = {
        setup: function () {
            $(this).bind('scroll', event.special.smartscroll.handler);
        },
        teardown: function () {
            $(this).unbind('scroll', event.special.smartscroll.handler);
        },
        handler: function (event, execAsap) {
            // Save the context
            var context = this,
            args = arguments;

            // set correct event type
            event.type = 'smartscroll';

            if (scrollTimeout) { clearTimeout(scrollTimeout); }
            scrollTimeout = setTimeout(function () {
                $(context).trigger('smartscroll', args);
            }, execAsap === 'execAsap' ? 0 : 100);
        }
    };

    $.fn.smartscroll = function (fn) {
        return fn ? this.bind('smartscroll', fn) : this.trigger('smartscroll', ['execAsap']);
    };

}));